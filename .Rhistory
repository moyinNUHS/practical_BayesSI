# set working directory to the `practical/` folder
wd = '~/Documents/GitHub/practical/'
setwd(wd)
# load libraries and functions
scripts = paste0(wd, 'Code/Functions/', list.files('Code/Functions/'))
lapply(scripts, source)
# set seed for reproducibility
set.seed(3127)
no_treatment = 4
pattern_list = list(pattern1 = c(2,3), # Treatment patterns
pattern2 = 1:3,
pattern3 = c(2,3,4),
pattern4 = c(1,2,3,4))
prob_pattern = c(P1 = 0.25, P2 = 0.25, P3 = 0.25, P4 = 0.25)
T_vector = c(0.35, 0.35, 0.35, 0.35)
res_rate_prior = c(0.35, 0.35, 0.35, 0.35)
N_patients_max = 100
N_patients_min = 50
N_patients_brk = 10
N_iter = 5
no_pattern<<-length(pattern)
pattern = 4
pattern = pattern_list
no_pattern<<-length(pattern)
no_pattern
no_comparison<<-sapply(1:no_pattern, function(i){length(pattern[[i]])-1})
no_comparison
pattern
no_treatment<<-length(unique(unlist(pattern)))
no_treatment
#res_probability_all<-matrix(rep(response_prob_V, no_pattern), ncol = no_treatment, byrow = T)
colnames(res_probability_all)<-sapply(1:no_treatment, function(i){paste0("treatment_", i)} )
res_probability_prior = res_rate_mat_prior
#Specify each treatment risk
alpha_ref = find_phi(T_vector[1], alpha)   # effect of reference treatment
alpha_ref
T_vector[1]
alpha
alpha = 0
#Specify each treatment risk
alpha_ref = find_phi(T_vector[1], alpha)   # effect of reference treatment
phi_vector = find_phi(p = T_vector,
alpha = alpha_ref)   # specify each treatment risk
res_rate = res_probability(phi_vector, alpha_ref) # probability of outcome for each treatment
#Specify sample size for each run
samplesize_vec = seq(N_patients_min, N_patients_max, by = N_patients_brk)
samplesize_vec
N = 100
res_rate_mat = matrix(res_rate, byrow = T,
nrow = length(pattern_list), # number of patterns
ncol = length(res_rate)) # number of treatments
res_rate_mat
res_rate_mat_prior = matrix(res_rate_prior, byrow = T,
nrow= length(pattern_list),
ncol = length(res_rate))
res_rate_mat_prior
res_rate_mat_prior = matrix(res_rate_prior, byrow = T,
nrow= length(pattern_list),
ncol = length(res_rate))
res_rate_mat_prior
res_rate_prior
phi_v = phi_vector
phi_v
#res_probability_all<-matrix(rep(response_prob_V, no_pattern), ncol = no_treatment, byrow = T)
colnames(res_probability_all)<-sapply(1:no_treatment, function(i){paste0("treatment_", i)} )
res_probability_all = res_rate_mat
#res_probability_all<-matrix(rep(response_prob_V, no_pattern), ncol = no_treatment, byrow = T)
colnames(res_probability_all)<-sapply(1:no_treatment, function(i){paste0("treatment_", i)} )
rownames(res_probability_all)<-sapply(1:no_pattern, function(i){paste0("alpha_", i)} )
res_probability_all
# each person has prob_pattern to be allocated to one of the treatment patterns
assigned_pattern<-t(rmultinom(N, size=1, prob_pattern))
assigned_pattern
colnames(assigned_pattern)<-sapply(1:no_pattern, function(i){paste0("subgroup", i)} )
assigned_pattern
N
prob_pattern
# number of patients in each subgroup that is defined by the pattern
size_pattern<<-apply(assigned_pattern, 2, sum)
size_pattern
# number of patients in each subgroup that is defined by the pattern
size_pattern<<-apply(assigned_pattern, 2, sum)
lambda<-prob_pattern # true prevalence rate of patterns
lambda
# number of patients in each subgroup that is defined by the pattern
size_pattern<<-apply(assigned_pattern, 2, sum)
size_pattern
true.response.r <- lapply(1:no_pattern,function(i)res_probability_all[i, pattern[[i]]])
true.response.r
true.mean.min <- lapply(1:no_pattern, function(i){
v <- true.response.r[[i]]
c("mean" = mean(v), "min" = min(v)) } )
true.mean.min
true.mean.min<-do.call(cbind, true.mean.min)
true.mean.min
#For Bayesian Framework, we must choose weight we wish to assign to prior distribution.
#We explore both a weakly & strongly informative prior distribution
Scale_wk <- 5     #Larger scale assigns less importance to prior distribution
Scale_str <- 1    #Smaller scale assigns more importance to prior distribution
# generate one prior dataset
Alldata_prior<-sapply(1:no_pattern, function(i){
generate_subset_data(i, size_pattern.=size_pattern,
pattern.=pattern, res_probability_all.=res_probability_prior)
})
gen.data<-function(j){
# generate one prior dataset
Alldata_prior<-sapply(1:no_pattern, function(i){
generate_subset_data(i, size_pattern.=size_pattern,
pattern.=pattern, res_probability_all.=res_probability_prior)
})
# generate one current dataset
Alldata<-sapply(1:no_pattern, function(i){
generate_subset_data(i, size_pattern.=size_pattern,
pattern.=pattern, res_probability_all.=res_probability_all)})
# show how many have been randomized to a treatment arm within a pattern
feq_t_subgroup<-sapply(1:no_pattern, function(i)table(Alldata[2,][[i]]))
# show how many have been randomized to each treatment arm
feq_t<-table(unlist(Alldata[2,]))
est_method_C<-fit_onestage_C(Alldata) # use original current data
est_method_C_NI<-fit_onestage_C_NI(Alldata) # use original current data
est_method_C_wk<-fit_onestage_C_prior(Alldata_prior, Alldata, Scale_wk) # use original current data +original prior data
est_method_C_str<-fit_onestage_C_prior(Alldata_prior, Alldata, Scale_str) # use original current data +original prior data
#Use a hierarchical structure
est_method_C2<-fit_onestage_C_hier(Alldata) # use original current data
est_method_C2_NI<-fit_onestage_C_hier_NI(Alldata) # use original current data
est_method_C2_wk<-fit_onestage_C_hier_prior(Alldata_prior, Alldata, Scale_wk) # use original current data +original prior data
est_method_C2_str<-fit_onestage_C_hier_prior(Alldata_prior, Alldata, Scale_str) # use original current data +original prior data
# combine estimated best treatments from all methods, row= methods, column= pattern
identified_best_t<-rbind(method_C=est_method_C$ranking[1,],
method_C_NI=est_method_C_NI$ranking[1,],
method_C_wk=est_method_C_wk$ranking[1,],
method_C_str=est_method_C_str$ranking[1,],
method_C2=est_method_C2$ranking[1,],
method_C2_NI=est_method_C2_NI$ranking[1,],
method_C2_wk=est_method_C2_wk$ranking[1,],
method_C2_str=est_method_C2_str$ranking[1,]
)
n_method<-dim(identified_best_t)[1]
identify_bestR<-function(k){
#v<-sapply(1:6, function(m){ which( pattern [[k]]==identified_best_t[m,k]) } )
#v<-sapply(1:6, function(m){
#  o1<-which( pattern [[k]]==identified_best_t[m,k])
#  if(length(o1)==0){NA}else{o1}
#} )
#t.rate<-true.response.r[[k]]
#t.rate<-t.rate[v]
#names(t.rate)<-rownames(identified_best_t)
v<-identified_best_t[,k]
t.rate<-res_probability_all[k,v]
return(t.rate)
}
# true response rate of the estimated best treatment for each pattern(column) from each method (row)
identify_best_rate<-sapply(1:no_pattern,identify_bestR)
# compute mortality reduction for each pattern(column) from each method (row)
mortality_gain<-t(sapply(1:n_method, function(m){identify_best_rate[m,]-true.mean.min[1,] }) )
better_treatment_I<-mortality_gain<0
# compute maximum possible mortality reduction for each pattern(column) from each method (row) if true best treatment known
mortality_gain_max<-true.mean.min[2,]-true.mean.min[1,]
# compute maximum possible mortality reduction ratio of each method vs if true best known
mortality_gain_ratio<-t(sapply(1:n_method, function(m){mortality_gain[m,]/mortality_gain_max }) )
diff_min<-t(sapply(1:n_method, function(m){ identify_best_rate[m,]-true.mean.min[2,]  }) )
best_treatment_I<-diff_min==0
nearbest_treatment_5<-diff_min-0.05 <= 0
nearbest_treatment_10<-diff_min-0.1 <= 0
rownames(mortality_gain)<-rownames(mortality_gain_ratio)<-rownames(better_treatment_I)<-rownames(identified_best_t)
rownames(diff_min)<-rownames(best_treatment_I)<-rownames(identified_best_t)
rownames(nearbest_treatment_5)<-rownames(nearbest_treatment_10)<-rownames(identified_best_t)
estimand2<-list(mortality_gain=mortality_gain,
mortality_gain_ratio=mortality_gain_ratio,
better_treatment_I=better_treatment_I,
best_treatment_I=best_treatment_I,
nearbest_treatment_5=nearbest_treatment_5,
nearbest_treatment_10=nearbest_treatment_10,
diff_min=diff_min )
#names(measure)<-c("pattern1", "pattern2", "pattern3", "pattern4", "pattern5", "pattern6", "pattern7", "pattern8")
identify_fail<-rbind(method_C=est_method_C$ranking[2,],
method_C_NI=est_method_C_NI$ranking[2,],
method_C_wk=est_method_C_wk$ranking[2,],
method_C_str=est_method_C_str$ranking[2,],
method_C2=est_method_C2$ranking[2,],
method_C2_NI=est_method_C2_NI$ranking[2,],
method_C2_wk=est_method_C2_wk$ranking[2,],
method_C2_str=est_method_C2_str$ranking[2,] )
list(identified_best_t=identified_best_t,
est_method_C=est_method_C$contrast.est,
est_method_C_NI=est_method_C_NI$contrast.est,
est_method_C_wk=est_method_C_wk$contrast.est,
est_method_C_str=est_method_C_str$contrast.est,
est_method_C2=est_method_C2$contrast.est,
est_method_C2_NI=est_method_C2_NI$contrast.est,
est_method_C2_wk=est_method_C2_wk$contrast.est,
est_method_C2_str=est_method_C2_str$contrast.est,
performance_m=estimand2,
identify_fail=identify_fail,
feq_t_subgroup=feq_t_subgroup, feq_t=feq_t)
}
# generate one prior dataset
Alldata_prior<-sapply(1:no_pattern, function(i){
generate_subset_data(i, size_pattern.=size_pattern,
pattern.=pattern, res_probability_all.=res_probability_prior)
})
res_probability_prior = res_rate_mat_prior
# generate one prior dataset
Alldata_prior <- sapply(1:no_pattern, function(i){
generate_subset_data(i,
size_pattern. = size_pattern,
pattern. = pattern,
res_probability_all. = res_probability_prior)
})
Alldata_prior
Alldata_prior[,1]
Alldata_prior[,1][1]
length(Alldata_prior[,1][1])
length(Alldata_prior[,1][[1])
length(Alldata_prior[,1][[1]])
# generate one current dataset
Alldata <- sapply(1:no_pattern, function(i){
generate_subset_data(i, size_pattern.=size_pattern,
pattern.=pattern, res_probability_all.=res_probability_all)
})
Alldata
Alldata_prior
# show how many have been randomized to a treatment arm within a pattern
feq_t_subgroup <- sapply(1:no_pattern, function(i) table(Alldata[2,][[i]]))
feq_t_subgroup
# show how many have been randomized to a treatment arm within a pattern
feq_t_subgroup <- sapply(1:no_pattern, function(i) table(Alldata[2,][[i]]))
# show how many have been randomized to each treatment arm
feq_t <- table(unlist(Alldata[2,]))
feq_t
est_method_C <- fit_onestage_C(Alldata) # use original current data
est_method_C
alldata=Alldata
no_p<-no_pattern
nma_data<-data.frame(y=unlist(alldata[1,]),
treatment=factor(unlist(alldata[2,]), levels = sort(unique(unlist(alldata[2,])))),
subgroup=factor(unlist(alldata[4,])))#patient_subgroup)))
my.glm<-myTryCatch(glm(y~treatment+ subgroup,family="binomial",data=nma_data) )
my.glm
q.val<-qnorm(0.975)
q.val
q.val<-qnorm(ci)
ci = 0.975
# Dunnett test
dunnett_test <- glht(my.glm,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
# scripts to load necessary libraries and scripts
## library list
require(pacman)
p_load(stringr,
multiwayvcov,
sandwich,
rstanarm,
modelsummary,
multilevelmod,
tidymodels,
lme4,
multcomp #http://www.ievbras.ru/ecostat/Kiril/R/Biblio_N/R_Eng/Bretz2011.pdf
)
t1_error = 0.05
no_p<-no_pattern
nma_data<-data.frame(y=unlist(alldata[1,]),
treatment=factor(unlist(alldata[2,]), levels = sort(unique(unlist(alldata[2,])))),
subgroup=factor(unlist(alldata[4,])))#patient_subgroup)))
my.glm<-myTryCatch(glm(y~ treatment + subgroup,family="binomial",data=nma_data) )
# Dunnett test
dunnett_test <- glht(my.glm,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
my.glm
# Dunnett test
dunnett_test <- glht(my.glm,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
# Dunnett test
dunnett_test <- glht(model = my.glm,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
?glht
# Dunnett test
dunnett_test <- glht(model = my.glm)
# model with GLM
model = glm(outcome ~ treatment, data = d)
# simulate data
d = data.frame(id = 1:400,
treatment = as.factor(rep(c('A', 'B', 'C', 'D'), each = 100)),
outcome = as.numeric(c(rep(c('0', '1'), c(50, 50)),
rep(c('0', '1'), c(10, 90)),
rep(c('0', '1'), c(30, 70)),
rep(c('0', '1'), c(40, 60))))
)
# model with GLM
model = glm(outcome ~ treatment, data = d)
summary(model)
model
# Dunnett test
dunnett_test = glht(model,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
my.glm
# Dunnett test
dunnett_test <- glht(model = my.glm$value,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
dunnett_test
# Step-down Dunnett test
stepdown = summary(dunnett_test, test = adjusted(type = "free"))
stepdown
# Output
data.frame(unadj = round(summary(model)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
data.frame(unadj = round(my.glm)$coeff[2:4,4], 5),
data.frame(unadj = round(summary(my.glm)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
data.frame(unadj = round(summary(myglm)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
data.frame(unadj = round(summary(my.glm)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
summary(my.glm)
data.frame(unadj = round(summary(my.glm$value)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
stepdown
my.glm<-my.glm[[1]]
mof<-summary(my.glm)
mof
vcov(mof)
vcov
?vcov
std.err<-sqrt(diag(vcov(mof))[2:no_treatment])
std.err
stepdown
my.glm
dunnett_test
stepdown
out<-cbind(Estimate=coefficients(mof)[2:no_treatment],
model_var=std.err^2,
z=coefficients(mof)[2:no_treatment]/std.err,
LL=coefficients(mof)[2:no_treatment] - q.val  * std.err,
UL=coefficients(mof)[2:no_treatment] + q.val  * std.err)
z
coefficients(mof)[2:no_treatment]
coefficients(mof)
std.err
round(summary(stepdown)$test$pvalues, 5)
out
data.frame(unadj = round(summary(my.glm$value)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
data.frame(unadj = round(summary(my.glm$value)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
data.frame(unadj = round(summary(my.glm)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
out
# Dunnett test
dunnett_test <- glht(model = my.glm,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
# Step-down Dunnett test
stepdown = summary(dunnett_test, test = adjusted(type = "free"))
data.frame(unadj = round(summary(my.glm)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
summary(my.glm)
out
stepdown
mof
std.err
# extract model output
my.glm<-my.glm[[1]]
mof<-summary(my.glm)
# Dunnett test
dunnett_test <- glht(model = my.glm,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
my.glm<-myTryCatch(glm(y~ treatment + subgroup,family="binomial",data=nma_data) )
# extract model output
my.glm<-my.glm[[1]]
mof<-summary(my.glm)
my.glm
mof
# Dunnett test
dunnett_test <- glht(model = my.glm,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
stepdown <- summary(dunnett_test, test = adjusted(type = "free"))
stepdown <- summary(dunnett_test, test = adjusted(type = "free")) # Step-down Dunnett test
stepdown
stepdown$vcov
stepdown$linfct
stepdown$model
stepdown$coef
str(stepdown)
stepdown
stepdown$df
stepdown$test
# get standard error
std.err<- stepdown$test$sigma
std.err
# get standard error
std.err <- stepdown$test$sigma
my.glm
mof
std.err
# Dunnett test
dunnett_test <- glht(model = my.glm,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
stepdown <- summary(dunnett_test, test = adjusted(type = "free")) # Step-down Dunnett test
stepdown
# get standard error
std.err <- stepdown$test$sigma # inflated
mof$coefficients
mof$coefficients[,2]
mof$coefficients[2:4,2]
std.err
std.err<-sqrt(diag(vcov(mof))[2:no_treatment])
std.err
stepdown
dunnett_test
my.glm
alt_hypothesis = 'two.sided'
t1_error = 0.05
# Dunnett test
dunnett_test <- glht(model = my.glm,
linfct = mcp(treatment = "Dunnett"),
alternative = alt_hypothesis)
dunnett_test
stepdown <- summary(dunnett_test, test = adjusted(type = "free")) # Step-down Dunnett test
stepdown
stepdown$coef
stepdown$test
stepdown$test$coefficients
coefficients(mof)[2:no_treatment]
stepdown
coefficients(mof)[2:no_treatment]/std.err
stepdown$rhs
out <- cbind(Estimate = stepdown$test$coefficients,
model_var = std.err^2,
z = stepdown$test$tstat,
LL = coefficients(mof)[2:no_treatment] - q.val  * std.err,
UL = coefficients(mof)[2:no_treatment] + q.val  * std.err)
stepdown$test$tstat
coefficients(mof)[2:no_treatment]
stepdown$test$coefficients
q.val<-qnorm(1 - (t1_error/2))
q.val<-qnorm(1 - t1_error/2)
q.val <- qnorm(1 - t1_error/2)
q.val
1 - t1_error/2
# simulate data
d = data.frame(id = 1:400,
treatment = as.factor(rep(c('A', 'B', 'C', 'D'), each = 100)),
outcome = as.numeric(c(rep(c('0', '1'), c(50, 50)),
rep(c('0', '1'), c(10, 90)),
rep(c('0', '1'), c(30, 70)),
rep(c('0', '1'), c(40, 60))))
)
head(d)
# model with GLM
model = glm(outcome ~ treatment, data = d)
summary(model)
# Dunnett test
dunnett_test = glht(model,
linfct = mcp(treatment = "Dunnett"),
alternative = c("two.sided"))
summary(dunnett_test)
# Step-down Dunnett test
stepdown = summary(dunnett_test, test = adjusted(type = "free"))
# Output
data.frame(unadj = round(summary(model)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
stepdown
summary(model)
4.17e-10
4.17e-10*10000000
6.55e-10*10000000
summary(model)$coeff
summary(dunnett_test)$test$pvalues
# Output of p values
data.frame(unadj = round(summary(model)$coeff[2:4,4], 5),
dunnett = round(summary(dunnett_test)$test$pvalues, 5),
stepdowndunnett = round(summary(stepdown)$test$pvalues, 5))
summary(stepdown)
summary(model)
# simulate data
d = data.frame(id = 1:400,
treatment = as.factor(rep(c('A', 'B', 'C', 'D'), each = 100)),
outcome = as.numeric(c(rep(c('0', '1'), c(50, 50)),
rep(c('0', '1'), c(10, 90)),
rep(c('0', '1'), c(30, 70)),
rep(c('0', '1'), c(40, 60))))
)
head(d)
# model with GLM
model = glm(outcome ~ treatment, data = d)
summary(model)
stepdown
d
summary(model)
stepdown
summary(model)
stepdown
summary(model)$coeff
